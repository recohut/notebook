<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="twitter:card" content="summary_large_image" /><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Objectworld RL MDP Environment | reconb</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Objectworld RL MDP Environment" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Jupyter notebook database." />
<meta property="og:description" content="Jupyter notebook database." />
<link rel="canonical" href="https://nb.recohut.com/2022/01/21/objectworld.html" />
<meta property="og:url" content="https://nb.recohut.com/2022/01/21/objectworld.html" />
<meta property="og:site_name" content="reconb" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-01-21T00:00:00-06:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Objectworld RL MDP Environment" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-01-21T00:00:00-06:00","datePublished":"2022-01-21T00:00:00-06:00","description":"Jupyter notebook database.","headline":"Objectworld RL MDP Environment","mainEntityOfPage":{"@type":"WebPage","@id":"https://nb.recohut.com/2022/01/21/objectworld.html"},"url":"https://nb.recohut.com/2022/01/21/objectworld.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="https://nb.recohut.com/feed.xml" title="reconb" /><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Primer/15.2.0/primer.css" integrity="sha512-xTz2ys4coGAOz8vuV1NcQBkgVmKhsSEtjbqyMJbBHRplFuvKIUo6xhLHpAyPt9mfR6twHJgn9OgVLuqOvjeBhg==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css" integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.css" integrity="sha512-h7nl+xz8wgDlNM4NqKEM4F1NkIRS17M9+uJwIGwuo8vGqIl4BhuCKdxjWEINm+xyrUjNCnK5dCrhM0sj+wTIXw==" crossorigin="anonymous" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.js" integrity="sha512-/CMIhXiDA3m2c9kzRyd97MTb3MC6OVnx4TElQ7fkkoRghwDf6gi41gaT1PwF270W6+J60uTmwgeRpNpJdRV6sg==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/contrib/auto-render.min.js" integrity="sha512-Do7uJAaHZm5OLrIv/yN4w0iG1dbu01kzdMNnFfu/mAqgUk6Nniv2JYHcwH+cNwjqgLcqcuBBk+JRvprLVI8azg==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha512-0doc9hKxR3PYwso42RD1p5ySZpzzuDiOwMrdCEh2WdJZCjcmFKc/wEnL+z8fBQrnHoiNWbo+3fiGkOYXBdQp4A==" crossorigin="anonymous"></script>
    <script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement( document.body, {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "[%", right: "%]", display: true},
            {left: "$", right: "$", display: false}
        ]}
        );
    });
    </script>


<script>
function wrap_img(fn) {
    if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") {
        var elements = document.querySelectorAll(".post img");
        Array.prototype.forEach.call(elements, function(el, i) {
            if (el.getAttribute("title") && (el.className != "emoji")) {
                const caption = document.createElement('figcaption');
                var node = document.createTextNode(el.getAttribute("title"));
                caption.appendChild(node);
                const wrapper = document.createElement('figure');
                wrapper.className = 'image';
                el.parentNode.insertBefore(wrapper, el);
                el.parentNode.removeChild(el);
                wrapper.appendChild(el);
                wrapper.appendChild(caption);
            }
        });
    } else { document.addEventListener('DOMContentLoaded', fn); }
}
window.onload = wrap_img;
</script>

<script>
    document.addEventListener("DOMContentLoaded", function(){
    // add link icon to anchor tags
    var elem = document.querySelectorAll(".anchor-link")
    elem.forEach(e => (e.innerHTML = '<i class="fas fa-link fa-xs"></i>'));
    });
</script>
</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">reconb</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About Me</a><a class="page-link" href="/search/">Search</a><a class="page-link" href="/categories/">Tags</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Objectworld RL MDP Environment</h1><p class="post-meta post-meta-title"><time class="dt-published" datetime="2022-01-21T00:00:00-06:00" itemprop="datePublished">
        Jan 21, 2022
      </time>
       â€¢ <span class="read-time" title="Estimated read time">
    
    
      17 min read
    
</span></p>

    

    
      
        <div class="pb-5 d-flex flex-justify-center">
          <div class="px-2">

    <a href="https://github.com/recohut/notebook/tree/master/_notebooks/2022-01-21-objectworld.ipynb" role="button" target="_blank">
<img class="notebook-badge-image" src="/assets/badges/github.svg" alt="View On GitHub">
    </a>
</div>

          <div class="px-2">
    <a href="https://mybinder.org/v2/gh/recohut/notebook/master?filepath=_notebooks%2F2022-01-21-objectworld.ipynb" target="_blank">
        <img class="notebook-badge-image" src="/assets/badges/binder.svg" alt="Open In Binder"/>
    </a>
</div>

          <div class="px-2">
    <a href="https://colab.research.google.com/github/recohut/notebook/blob/master/_notebooks/2022-01-21-objectworld.ipynb" target="_blank">
        <img class="notebook-badge-image" src="/assets/badges/colab.svg" alt="Open In Colab"/>
    </a>
</div>
          <div class="px-2">
  <a href="https://deepnote.com/launch?url=https%3A%2F%2Fgithub.com%2Frecohut%2Fnotebook%2Fblob%2Fmaster%2F_notebooks%2F2022-01-21-objectworld.ipynb" target="_blank">
      <img class="notebook-badge-image" src="/assets/badges/deepnote.svg" alt="Launch in Deepnote"/>
  </a>
</div>

        </div>
      </header>

  <div class="post-content e-content" itemprop="articleBody">
    <!--
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: _notebooks/2022-01-21-objectworld.ipynb
-->

<div class="container" id="notebook-container">
        
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-python"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numpy.random</span> <span class="k">as</span> <span class="nn">rn</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">product</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Gridworld">Gridworld<a class="anchor-link" href="#Gridworld"> </a></h2><p>Implements the gridworld MDP. Matthew Alger, 2015.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-python"><pre><span></span><span class="k">class</span> <span class="nc">Gridworld</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gridworld MDP.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid_size</span><span class="p">,</span> <span class="n">wind</span><span class="p">,</span> <span class="n">discount</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        grid_size: Grid size. int.</span>
<span class="sd">        wind: Chance of moving randomly. float.</span>
<span class="sd">        discount: MDP discount. float.</span>
<span class="sd">        -&gt; Gridworld</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">actions</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_actions</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">actions</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_states</span> <span class="o">=</span> <span class="n">grid_size</span><span class="o">**</span><span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span> <span class="o">=</span> <span class="n">grid_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wind</span> <span class="o">=</span> <span class="n">wind</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">discount</span> <span class="o">=</span> <span class="n">discount</span>

        <span class="c1"># Preconstruct the transition probability array.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transition_probability</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[[[</span><span class="bp">self</span><span class="o">.</span><span class="n">_transition_probability</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
               <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_states</span><span class="p">)]</span>
              <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_actions</span><span class="p">)]</span>
             <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_states</span><span class="p">)])</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;Gridworld(</span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wind</span><span class="p">,</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">discount</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">feature_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">feature_map</span><span class="o">=</span><span class="s2">&quot;ident&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the feature vector associated with a state integer.</span>

<span class="sd">        i: State int.</span>
<span class="sd">        feature_map: Which feature map to use (default ident). String in {ident,</span>
<span class="sd">            coord, proxi}.</span>
<span class="sd">        -&gt; Feature vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">feature_map</span> <span class="o">==</span> <span class="s2">&quot;coord&quot;</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="p">)</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">i</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="p">,</span> <span class="n">i</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span>
            <span class="n">f</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">f</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">f</span>
        <span class="k">if</span> <span class="n">feature_map</span> <span class="o">==</span> <span class="s2">&quot;proxi&quot;</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_states</span><span class="p">)</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">i</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="p">,</span> <span class="n">i</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="p">):</span>
                    <span class="n">dist</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span>
                    <span class="n">f</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">point_to_int</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))]</span> <span class="o">=</span> <span class="n">dist</span>
            <span class="k">return</span> <span class="n">f</span>
        <span class="c1"># Assume identity map.</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_states</span><span class="p">)</span>
        <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">f</span>

    <span class="k">def</span> <span class="nf">feature_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">feature_map</span><span class="o">=</span><span class="s2">&quot;ident&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the feature matrix for this gridworld.</span>

<span class="sd">        feature_map: Which feature map to use (default ident). String in {ident,</span>
<span class="sd">            coord, proxi}.</span>
<span class="sd">        -&gt; NumPy array with shape (n_states, d_states).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">features</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_states</span><span class="p">):</span>
            <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_vector</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">feature_map</span><span class="p">)</span>
            <span class="n">features</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">features</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">int_to_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a state int into the corresponding coordinate.</span>

<span class="sd">        i: State int.</span>
<span class="sd">        -&gt; (x, y) int tuple.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="p">,</span> <span class="n">i</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">point_to_int</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a coordinate into the corresponding state int.</span>

<span class="sd">        p: (x, y) tuple.</span>
<span class="sd">        -&gt; State int.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span>

    <span class="k">def</span> <span class="nf">neighbouring</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get whether two points neighbour each other. Also returns true if they</span>
<span class="sd">        are the same point.</span>

<span class="sd">        i: (x, y) int tuple.</span>
<span class="sd">        k: (x, y) int tuple.</span>
<span class="sd">        -&gt; bool.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_transition_probability</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the probability of transitioning from state i to state k given</span>
<span class="sd">        action j.</span>

<span class="sd">        i: State int.</span>
<span class="sd">        j: Action int.</span>
<span class="sd">        k: State int.</span>
<span class="sd">        -&gt; p(s_k | s_i, a_j)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">int_to_point</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">xj</span><span class="p">,</span> <span class="n">yj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">actions</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="n">xk</span><span class="p">,</span> <span class="n">yk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">int_to_point</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">neighbouring</span><span class="p">((</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">),</span> <span class="p">(</span><span class="n">xk</span><span class="p">,</span> <span class="n">yk</span><span class="p">)):</span>
            <span class="k">return</span> <span class="mf">0.0</span>

        <span class="c1"># Is k the intended state to move to?</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">xi</span> <span class="o">+</span> <span class="n">xj</span><span class="p">,</span> <span class="n">yi</span> <span class="o">+</span> <span class="n">yj</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">xk</span><span class="p">,</span> <span class="n">yk</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">wind</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">wind</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">n_actions</span>

        <span class="c1"># If these are not the same point, then we can move there by wind.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">xk</span><span class="p">,</span> <span class="n">yk</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wind</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">n_actions</span>

        <span class="c1"># If these are the same point, we can only move here by either moving</span>
        <span class="c1"># off the grid or being blown off the grid. Are we on a corner or not?</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">)</span> <span class="ow">in</span> <span class="p">{(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                        <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)}:</span>
            <span class="c1"># Corner.</span>
            <span class="c1"># Can move off the edge in two directions.</span>
            <span class="c1"># Did we intend to move off the grid?</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">xi</span> <span class="o">+</span> <span class="n">xj</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span> <span class="ow">and</span>
                    <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">yi</span> <span class="o">+</span> <span class="n">yj</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="p">):</span>
                <span class="c1"># We intended to move off the grid, so we have the regular</span>
                <span class="c1"># success chance of staying here plus an extra chance of blowing</span>
                <span class="c1"># onto the *other* off-grid square.</span>
                <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">wind</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">wind</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">n_actions</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># We can blow off the grid in either direction only by wind.</span>
                <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">wind</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">n_actions</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Not a corner. Is it an edge?</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">xi</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="o">-</span><span class="mi">1</span><span class="p">}</span> <span class="ow">and</span>
                <span class="n">yi</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="o">-</span><span class="mi">1</span><span class="p">}):</span>
                <span class="c1"># Not an edge.</span>
                <span class="k">return</span> <span class="mf">0.0</span>

            <span class="c1"># Edge.</span>
            <span class="c1"># Can only move off the edge in one direction.</span>
            <span class="c1"># Did we intend to move off the grid?</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">xi</span> <span class="o">+</span> <span class="n">xj</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span> <span class="ow">and</span>
                    <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">yi</span> <span class="o">+</span> <span class="n">yj</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="p">):</span>
                <span class="c1"># We intended to move off the grid, so we have the regular</span>
                <span class="c1"># success chance of staying here.</span>
                <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">wind</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">wind</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">n_actions</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># We can blow off the grid only by wind.</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wind</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">n_actions</span>

    <span class="k">def</span> <span class="nf">reward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state_int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reward for being in state state_int.</span>

<span class="sd">        state_int: State integer. int.</span>
<span class="sd">        -&gt; Reward.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">state_int</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_states</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">average_reward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_trajectories</span><span class="p">,</span> <span class="n">trajectory_length</span><span class="p">,</span> <span class="n">policy</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the average total reward obtained by following a given policy</span>
<span class="sd">        over n_paths paths.</span>

<span class="sd">        policy: Map from state integers to action integers.</span>
<span class="sd">        n_trajectories: Number of trajectories. int.</span>
<span class="sd">        trajectory_length: Length of an episode. int.</span>
<span class="sd">        -&gt; Average reward, standard deviation.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">trajectories</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_trajectories</span><span class="p">(</span><span class="n">n_trajectories</span><span class="p">,</span>
                                             <span class="n">trajectory_length</span><span class="p">,</span> <span class="n">policy</span><span class="p">)</span>
        <span class="n">rewards</span> <span class="o">=</span> <span class="p">[[</span><span class="n">r</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">trajectory</span><span class="p">]</span> <span class="k">for</span> <span class="n">trajectory</span> <span class="ow">in</span> <span class="n">trajectories</span><span class="p">]</span>
        <span class="n">rewards</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rewards</span><span class="p">)</span>

        <span class="c1"># Add up all the rewards to find the total reward.</span>
        <span class="n">total_reward</span> <span class="o">=</span> <span class="n">rewards</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Return the average reward and standard deviation.</span>
        <span class="k">return</span> <span class="n">total_reward</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="n">total_reward</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">optimal_policy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state_int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The optimal policy for this gridworld.</span>

<span class="sd">        state_int: What state we are in. int.</span>
<span class="sd">        -&gt; Action int.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">sx</span><span class="p">,</span> <span class="n">sy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">int_to_point</span><span class="p">(</span><span class="n">state_int</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">sx</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span> <span class="ow">and</span> <span class="n">sy</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">rn</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sx</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">sy</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unexpected state.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">optimal_policy_deterministic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state_int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deterministic version of the optimal policy for this gridworld.</span>

<span class="sd">        state_int: What state we are in. int.</span>
<span class="sd">        -&gt; Action int.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">sx</span><span class="p">,</span> <span class="n">sy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">int_to_point</span><span class="p">(</span><span class="n">state_int</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sx</span> <span class="o">&lt;</span> <span class="n">sy</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">generate_trajectories</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_trajectories</span><span class="p">,</span> <span class="n">trajectory_length</span><span class="p">,</span> <span class="n">policy</span><span class="p">,</span>
                                    <span class="n">random_start</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate n_trajectories trajectories with length trajectory_length,</span>
<span class="sd">        following the given policy.</span>

<span class="sd">        n_trajectories: Number of trajectories. int.</span>
<span class="sd">        trajectory_length: Length of an episode. int.</span>
<span class="sd">        policy: Map from state integers to action integers.</span>
<span class="sd">        random_start: Whether to start randomly (default False). bool.</span>
<span class="sd">        -&gt; [[(state int, action int, reward float)]]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">trajectories</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_trajectories</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">random_start</span><span class="p">:</span>
                <span class="n">sx</span><span class="p">,</span> <span class="n">sy</span> <span class="o">=</span> <span class="n">rn</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="p">),</span> <span class="n">rn</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sx</span><span class="p">,</span> <span class="n">sy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>

            <span class="n">trajectory</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">trajectory_length</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">rn</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">wind</span><span class="p">:</span>
                    <span class="n">action</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">actions</span><span class="p">[</span><span class="n">rn</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Follow the given policy.</span>
                    <span class="n">action</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">actions</span><span class="p">[</span><span class="n">policy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">point_to_int</span><span class="p">((</span><span class="n">sx</span><span class="p">,</span> <span class="n">sy</span><span class="p">)))]</span>

                <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">sx</span> <span class="o">+</span> <span class="n">action</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span> <span class="ow">and</span>
                        <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">sy</span> <span class="o">+</span> <span class="n">action</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="p">):</span>
                    <span class="n">next_sx</span> <span class="o">=</span> <span class="n">sx</span> <span class="o">+</span> <span class="n">action</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">next_sy</span> <span class="o">=</span> <span class="n">sy</span> <span class="o">+</span> <span class="n">action</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">next_sx</span> <span class="o">=</span> <span class="n">sx</span>
                    <span class="n">next_sy</span> <span class="o">=</span> <span class="n">sy</span>

                <span class="n">state_int</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">point_to_int</span><span class="p">((</span><span class="n">sx</span><span class="p">,</span> <span class="n">sy</span><span class="p">))</span>
                <span class="n">action_int</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">actions</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">action</span><span class="p">)</span>
                <span class="n">next_state_int</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">point_to_int</span><span class="p">((</span><span class="n">next_sx</span><span class="p">,</span> <span class="n">next_sy</span><span class="p">))</span>
                <span class="n">reward</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reward</span><span class="p">(</span><span class="n">next_state_int</span><span class="p">)</span>
                <span class="n">trajectory</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">state_int</span><span class="p">,</span> <span class="n">action_int</span><span class="p">,</span> <span class="n">reward</span><span class="p">))</span>

                <span class="n">sx</span> <span class="o">=</span> <span class="n">next_sx</span>
                <span class="n">sy</span> <span class="o">=</span> <span class="n">next_sy</span>

            <span class="n">trajectories</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trajectory</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">trajectories</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Objectworld">Objectworld<a class="anchor-link" href="#Objectworld"> </a></h2><p>Implements the objectworld MDP described in Levine et al. 2011. Matthew Alger, 2015.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-python"><pre><span></span><span class="k">class</span> <span class="nc">OWObject</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Object in objectworld.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inner_colour</span><span class="p">,</span> <span class="n">outer_colour</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        inner_colour: Inner colour of object. int.</span>
<span class="sd">        outer_colour: Outer colour of object. int.</span>
<span class="sd">        -&gt; OWObject</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">inner_colour</span> <span class="o">=</span> <span class="n">inner_colour</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outer_colour</span> <span class="o">=</span> <span class="n">outer_colour</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A string representation of this object.</span>
<span class="sd">        -&gt; __str__</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="s2">&quot;&lt;OWObject (In: </span><span class="si">{}</span><span class="s2">) (Out: </span><span class="si">{}</span><span class="s2">)&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inner_colour</span><span class="p">,</span>
                                                      <span class="bp">self</span><span class="o">.</span><span class="n">outer_colour</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-python"><pre><span></span><span class="k">class</span> <span class="nc">Objectworld</span><span class="p">(</span><span class="n">Gridworld</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Objectworld MDP.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid_size</span><span class="p">,</span> <span class="n">n_objects</span><span class="p">,</span> <span class="n">n_colours</span><span class="p">,</span> <span class="n">wind</span><span class="p">,</span> <span class="n">discount</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        grid_size: Grid size. int.</span>
<span class="sd">        n_objects: Number of objects in the world. int.</span>
<span class="sd">        n_colours: Number of colours to colour objects with. int.</span>
<span class="sd">        wind: Chance of moving randomly. float.</span>
<span class="sd">        discount: MDP discount. float.</span>
<span class="sd">        -&gt; Objectworld</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">grid_size</span><span class="p">,</span> <span class="n">wind</span><span class="p">,</span> <span class="n">discount</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">actions</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_actions</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">actions</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_objects</span> <span class="o">=</span> <span class="n">n_objects</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_colours</span> <span class="o">=</span> <span class="n">n_colours</span>

        <span class="c1"># Generate objects.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">objects</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_objects</span><span class="p">):</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">OWObject</span><span class="p">(</span><span class="n">rn</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_colours</span><span class="p">),</span>
                           <span class="n">rn</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_colours</span><span class="p">))</span>

            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">rn</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="p">)</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">rn</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="p">)</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">:</span>
                    <span class="k">break</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span>

        <span class="c1"># Preconstruct the transition probability array.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transition_probability</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[[[</span><span class="bp">self</span><span class="o">.</span><span class="n">_transition_probability</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
               <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_states</span><span class="p">)]</span>
              <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_actions</span><span class="p">)]</span>
             <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_states</span><span class="p">)])</span>

    <span class="k">def</span> <span class="nf">feature_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">discrete</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the feature vector associated with a state integer.</span>
<span class="sd">        i: State int.</span>
<span class="sd">        discrete: Whether the feature vectors should be discrete (default True).</span>
<span class="sd">            bool.</span>
<span class="sd">        -&gt; Feature vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">sx</span><span class="p">,</span> <span class="n">sy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">int_to_point</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="n">nearest_inner</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># colour: distance</span>
        <span class="n">nearest_outer</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># colour: distance</span>

        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">:</span>
                    <span class="n">dist</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">hypot</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">sx</span><span class="p">),</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">sy</span><span class="p">))</span>
                    <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">inner_colour</span> <span class="ow">in</span> <span class="n">nearest_inner</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">dist</span> <span class="o">&lt;</span> <span class="n">nearest_inner</span><span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="n">inner_colour</span><span class="p">]:</span>
                            <span class="n">nearest_inner</span><span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="n">inner_colour</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">nearest_inner</span><span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="n">inner_colour</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span>
                    <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">outer_colour</span> <span class="ow">in</span> <span class="n">nearest_outer</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">dist</span> <span class="o">&lt;</span> <span class="n">nearest_outer</span><span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="n">outer_colour</span><span class="p">]:</span>
                            <span class="n">nearest_outer</span><span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="n">outer_colour</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">nearest_outer</span><span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="n">outer_colour</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span>

        <span class="c1"># Need to ensure that all colours are represented.</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_colours</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">nearest_inner</span><span class="p">:</span>
                <span class="n">nearest_inner</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">nearest_outer</span><span class="p">:</span>
                <span class="n">nearest_outer</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">discrete</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_colours</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="p">,))</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_colours</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">nearest_inner</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">:</span>
                        <span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">nearest_outer</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">:</span>
                        <span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">assert</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_colours</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span>
            <span class="k">assert</span> <span class="p">(</span><span class="n">state</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Continuous features.</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_colours</span><span class="p">))</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_colours</span><span class="p">):</span>
                <span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nearest_inner</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nearest_outer</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">state</span>

    <span class="k">def</span> <span class="nf">feature_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">discrete</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the feature matrix for this objectworld.</span>
<span class="sd">        discrete: Whether the feature vectors should be discrete (default True).</span>
<span class="sd">            bool.</span>
<span class="sd">        -&gt; NumPy array with shape (n_states, n_states).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">feature_vector</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">discrete</span><span class="p">)</span>
                         <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_states</span><span class="p">)])</span>

    <span class="k">def</span> <span class="nf">reward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state_int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the reward for a state int.</span>
<span class="sd">        state_int: State int.</span>
<span class="sd">        -&gt; reward float</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">int_to_point</span><span class="p">(</span><span class="n">state_int</span><span class="p">)</span>

        <span class="n">near_c0</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">near_c1</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">)</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)):</span>
            <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">dx</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">dy</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dy</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">3</span> <span class="ow">and</span>
                        <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">dx</span><span class="p">,</span> <span class="n">y</span><span class="o">+</span><span class="n">dy</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">objects</span> <span class="ow">and</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="n">x</span><span class="o">+</span><span class="n">dx</span><span class="p">,</span> <span class="n">y</span><span class="o">+</span><span class="n">dy</span><span class="p">]</span><span class="o">.</span><span class="n">outer_colour</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="n">near_c0</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dy</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span>
                        <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">dx</span><span class="p">,</span> <span class="n">y</span><span class="o">+</span><span class="n">dy</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">objects</span> <span class="ow">and</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="n">x</span><span class="o">+</span><span class="n">dx</span><span class="p">,</span> <span class="n">y</span><span class="o">+</span><span class="n">dy</span><span class="p">]</span><span class="o">.</span><span class="n">outer_colour</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">near_c1</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">near_c0</span> <span class="ow">and</span> <span class="n">near_c1</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">near_c0</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">generate_trajectories</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_trajectories</span><span class="p">,</span> <span class="n">trajectory_length</span><span class="p">,</span> <span class="n">policy</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate n_trajectories trajectories with length trajectory_length.</span>
<span class="sd">        n_trajectories: Number of trajectories. int.</span>
<span class="sd">        trajectory_length: Length of an episode. int.</span>
<span class="sd">        policy: Map from state integers to action integers.</span>
<span class="sd">        -&gt; [[(state int, action int, reward float)]]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">generate_trajectories</span><span class="p">(</span><span class="n">n_trajectories</span><span class="p">,</span> <span class="n">trajectory_length</span><span class="p">,</span>
                                             <span class="n">policy</span><span class="p">,</span>
                                             <span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">optimal_policy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state_int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;Optimal policy is not implemented for Objectworld.&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">optimal_policy_deterministic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state_int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;Optimal policy is not implemented for Objectworld.&quot;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="MaxEnt-Algorithm">MaxEnt Algorithm<a class="anchor-link" href="#MaxEnt-Algorithm"> </a></h2>
</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-python"><pre><span></span><span class="k">def</span> <span class="nf">irl</span><span class="p">(</span><span class="n">feature_matrix</span><span class="p">,</span> <span class="n">n_actions</span><span class="p">,</span> <span class="n">discount</span><span class="p">,</span> <span class="n">transition_probability</span><span class="p">,</span>
        <span class="n">trajectories</span><span class="p">,</span> <span class="n">epochs</span><span class="p">,</span> <span class="n">learning_rate</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the reward function for the given trajectories.</span>
<span class="sd">    feature_matrix: Matrix with the nth row representing the nth state. NumPy</span>
<span class="sd">        array with shape (N, D) where N is the number of states and D is the</span>
<span class="sd">        dimensionality of the state.</span>
<span class="sd">    n_actions: Number of actions A. int.</span>
<span class="sd">    discount: Discount factor of the MDP. float.</span>
<span class="sd">    transition_probability: NumPy array mapping (state_i, action, state_k) to</span>
<span class="sd">        the probability of transitioning from state_i to state_k under action.</span>
<span class="sd">        Shape (N, A, N).</span>
<span class="sd">    trajectories: 3D array of state/action pairs. States are ints, actions</span>
<span class="sd">        are ints. NumPy array with shape (T, L, 2) where T is the number of</span>
<span class="sd">        trajectories and L is the trajectory length.</span>
<span class="sd">    epochs: Number of gradient descent steps. int.</span>
<span class="sd">    learning_rate: Gradient descent learning rate. float.</span>
<span class="sd">    -&gt; Reward vector with shape (N,).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n_states</span><span class="p">,</span> <span class="n">d_states</span> <span class="o">=</span> <span class="n">feature_matrix</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1"># Initialise weights.</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">rn</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">d_states</span><span class="p">,))</span>

    <span class="c1"># Calculate the feature expectations \tilde{phi}.</span>
    <span class="n">feature_expectations</span> <span class="o">=</span> <span class="n">find_feature_expectations</span><span class="p">(</span><span class="n">feature_matrix</span><span class="p">,</span>
                                                     <span class="n">trajectories</span><span class="p">)</span>

    <span class="c1"># Gradient descent on alpha.</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">epochs</span><span class="p">):</span>
        <span class="c1"># print(&quot;i: {}&quot;.format(i))</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">feature_matrix</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">expected_svf</span> <span class="o">=</span> <span class="n">find_expected_svf</span><span class="p">(</span><span class="n">n_states</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">n_actions</span><span class="p">,</span> <span class="n">discount</span><span class="p">,</span>
                                         <span class="n">transition_probability</span><span class="p">,</span> <span class="n">trajectories</span><span class="p">)</span>
        <span class="n">grad</span> <span class="o">=</span> <span class="n">feature_expectations</span> <span class="o">-</span> <span class="n">feature_matrix</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">expected_svf</span><span class="p">)</span>

        <span class="n">alpha</span> <span class="o">+=</span> <span class="n">learning_rate</span> <span class="o">*</span> <span class="n">grad</span>

    <span class="k">return</span> <span class="n">feature_matrix</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">n_states</span><span class="p">,))</span>

<span class="k">def</span> <span class="nf">find_svf</span><span class="p">(</span><span class="n">n_states</span><span class="p">,</span> <span class="n">trajectories</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the state visitation frequency from trajectories.</span>
<span class="sd">    n_states: Number of states. int.</span>
<span class="sd">    trajectories: 3D array of state/action pairs. States are ints, actions</span>
<span class="sd">        are ints. NumPy array with shape (T, L, 2) where T is the number of</span>
<span class="sd">        trajectories and L is the trajectory length.</span>
<span class="sd">    -&gt; State visitation frequencies vector with shape (N,).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">svf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_states</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">trajectory</span> <span class="ow">in</span> <span class="n">trajectories</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">state</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">trajectory</span><span class="p">:</span>
            <span class="n">svf</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">svf</span> <span class="o">/=</span> <span class="n">trajectories</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">svf</span>

<span class="k">def</span> <span class="nf">find_feature_expectations</span><span class="p">(</span><span class="n">feature_matrix</span><span class="p">,</span> <span class="n">trajectories</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the feature expectations for the given trajectories. This is the</span>
<span class="sd">    average path feature vector.</span>
<span class="sd">    feature_matrix: Matrix with the nth row representing the nth state. NumPy</span>
<span class="sd">        array with shape (N, D) where N is the number of states and D is the</span>
<span class="sd">        dimensionality of the state.</span>
<span class="sd">    trajectories: 3D array of state/action pairs. States are ints, actions</span>
<span class="sd">        are ints. NumPy array with shape (T, L, 2) where T is the number of</span>
<span class="sd">        trajectories and L is the trajectory length.</span>
<span class="sd">    -&gt; Feature expectations vector with shape (D,).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">feature_expectations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">feature_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">trajectory</span> <span class="ow">in</span> <span class="n">trajectories</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">state</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">trajectory</span><span class="p">:</span>
            <span class="n">feature_expectations</span> <span class="o">+=</span> <span class="n">feature_matrix</span><span class="p">[</span><span class="n">state</span><span class="p">]</span>

    <span class="n">feature_expectations</span> <span class="o">/=</span> <span class="n">trajectories</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">feature_expectations</span>

<span class="k">def</span> <span class="nf">find_expected_svf</span><span class="p">(</span><span class="n">n_states</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">n_actions</span><span class="p">,</span> <span class="n">discount</span><span class="p">,</span>
                      <span class="n">transition_probability</span><span class="p">,</span> <span class="n">trajectories</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the expected state visitation frequencies using algorithm 1 from</span>
<span class="sd">    Ziebart et al. 2008.</span>
<span class="sd">    n_states: Number of states N. int.</span>
<span class="sd">    alpha: Reward. NumPy array with shape (N,).</span>
<span class="sd">    n_actions: Number of actions A. int.</span>
<span class="sd">    discount: Discount factor of the MDP. float.</span>
<span class="sd">    transition_probability: NumPy array mapping (state_i, action, state_k) to</span>
<span class="sd">        the probability of transitioning from state_i to state_k under action.</span>
<span class="sd">        Shape (N, A, N).</span>
<span class="sd">    trajectories: 3D array of state/action pairs. States are ints, actions</span>
<span class="sd">        are ints. NumPy array with shape (T, L, 2) where T is the number of</span>
<span class="sd">        trajectories and L is the trajectory length.</span>
<span class="sd">    -&gt; Expected state visitation frequencies vector with shape (N,).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n_trajectories</span> <span class="o">=</span> <span class="n">trajectories</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">trajectory_length</span> <span class="o">=</span> <span class="n">trajectories</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># policy = find_policy(n_states, r, n_actions, discount,</span>
    <span class="c1">#                                 transition_probability)</span>
    <span class="n">policy</span> <span class="o">=</span> <span class="n">find_policy</span><span class="p">(</span><span class="n">n_states</span><span class="p">,</span> <span class="n">n_actions</span><span class="p">,</span>
                                         <span class="n">transition_probability</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">discount</span><span class="p">)</span>

    <span class="n">start_state_count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_states</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">trajectory</span> <span class="ow">in</span> <span class="n">trajectories</span><span class="p">:</span>
        <span class="n">start_state_count</span><span class="p">[</span><span class="n">trajectory</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">p_start_state</span> <span class="o">=</span> <span class="n">start_state_count</span><span class="o">/</span><span class="n">n_trajectories</span>

    <span class="n">expected_svf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">p_start_state</span><span class="p">,</span> <span class="p">(</span><span class="n">trajectory_length</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">trajectory_length</span><span class="p">):</span>
        <span class="n">expected_svf</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_states</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_actions</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_states</span><span class="p">)):</span>
            <span class="n">expected_svf</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">expected_svf</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">t</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span>
                                  <span class="n">policy</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="c1"># Stochastic policy</span>
                                  <span class="n">transition_probability</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">expected_svf</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">softmax</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Soft-maximum calculation, from algorithm 9.2 in Ziebart&#39;s PhD thesis.</span>
<span class="sd">    x1: float.</span>
<span class="sd">    x2: float.</span>
<span class="sd">    -&gt; softmax(x1, x2)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">max_x</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
    <span class="n">min_x</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">max_x</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">min_x</span> <span class="o">-</span> <span class="n">max_x</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">find_policy</span><span class="p">(</span><span class="n">n_states</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">n_actions</span><span class="p">,</span> <span class="n">discount</span><span class="p">,</span>
                           <span class="n">transition_probability</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find a policy with linear value iteration. Based on the code accompanying</span>
<span class="sd">    the Levine et al. GPIRL paper and on Ziebart&#39;s PhD thesis (algorithm 9.1).</span>
<span class="sd">    n_states: Number of states N. int.</span>
<span class="sd">    r: Reward. NumPy array with shape (N,).</span>
<span class="sd">    n_actions: Number of actions A. int.</span>
<span class="sd">    discount: Discount factor of the MDP. float.</span>
<span class="sd">    transition_probability: NumPy array mapping (state_i, action, state_k) to</span>
<span class="sd">        the probability of transitioning from state_i to state_k under action.</span>
<span class="sd">        Shape (N, A, N).</span>
<span class="sd">    -&gt; NumPy array of states and the probability of taking each action in that</span>
<span class="sd">        state, with shape (N, A).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># V = value(n_states, transition_probability, r, discount)</span>

    <span class="c1"># NumPy&#39;s dot really dislikes using inf, so I&#39;m making everything finite</span>
    <span class="c1"># using nan_to_num.</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n_states</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;-inf&quot;</span><span class="p">))</span>

    <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n_states</span><span class="p">,))</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">diff</span> <span class="o">&gt;</span> <span class="mf">1e-4</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>  <span class="c1"># Iterate until convergence.</span>
        <span class="n">new_V</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_actions</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_states</span><span class="p">):</span>
                <span class="n">new_V</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">softmax</span><span class="p">(</span><span class="n">new_V</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">discount</span><span class="o">*</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">transition_probability</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">V</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                           <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_states</span><span class="p">)))</span>

        <span class="c1"># # This seems to diverge, so we z-score it (engineering hack).</span>
        <span class="n">new_V</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_V</span> <span class="o">-</span> <span class="n">new_V</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span><span class="o">/</span><span class="n">new_V</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>

        <span class="n">diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">V</span> <span class="o">-</span> <span class="n">new_V</span><span class="p">)</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">new_V</span>

    <span class="c1"># We really want Q, not V, so grab that using equation 9.2 from the thesis.</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_states</span><span class="p">,</span> <span class="n">n_actions</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_states</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_actions</span><span class="p">):</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">transition_probability</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>
                          <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_states</span><span class="p">)])</span>
            <span class="n">Q</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="n">discount</span><span class="o">*</span><span class="n">V</span><span class="p">)</span>

    <span class="c1"># Softmax by row to interpret these values as probabilities.</span>
    <span class="n">Q</span> <span class="o">-=</span> <span class="n">Q</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">n_states</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>  <span class="c1"># For numerical stability.</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">n_states</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">Q</span>

<span class="k">def</span> <span class="nf">expected_value_difference</span><span class="p">(</span><span class="n">n_states</span><span class="p">,</span> <span class="n">n_actions</span><span class="p">,</span> <span class="n">transition_probability</span><span class="p">,</span>
    <span class="n">reward</span><span class="p">,</span> <span class="n">discount</span><span class="p">,</span> <span class="n">p_start_state</span><span class="p">,</span> <span class="n">optimal_value</span><span class="p">,</span> <span class="n">true_reward</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the expected value difference, which is a proxy to how good a</span>
<span class="sd">    recovered reward function is.</span>
<span class="sd">    n_states: Number of states. int.</span>
<span class="sd">    n_actions: Number of actions. int.</span>
<span class="sd">    transition_probability: NumPy array mapping (state_i, action, state_k) to</span>
<span class="sd">        the probability of transitioning from state_i to state_k under action.</span>
<span class="sd">        Shape (N, A, N).</span>
<span class="sd">    reward: Reward vector mapping state int to reward. Shape (N,).</span>
<span class="sd">    discount: Discount factor. float.</span>
<span class="sd">    p_start_state: Probability vector with the ith component as the probability</span>
<span class="sd">        that the ith state is the start state. Shape (N,).</span>
<span class="sd">    optimal_value: Value vector for the ground reward with optimal policy.</span>
<span class="sd">        The ith component is the value of the ith state. Shape (N,).</span>
<span class="sd">    true_reward: True reward vector. Shape (N,).</span>
<span class="sd">    -&gt; Expected value difference. float.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">policy</span> <span class="o">=</span> <span class="n">find_policy</span><span class="p">(</span><span class="n">n_states</span><span class="p">,</span> <span class="n">n_actions</span><span class="p">,</span>
        <span class="n">transition_probability</span><span class="p">,</span> <span class="n">reward</span><span class="p">,</span> <span class="n">discount</span><span class="p">)</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">(</span><span class="n">policy</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">n_states</span><span class="p">,</span>
        <span class="n">transition_probability</span><span class="p">,</span> <span class="n">true_reward</span><span class="p">,</span> <span class="n">discount</span><span class="p">)</span>

    <span class="n">evd</span> <span class="o">=</span> <span class="n">optimal_value</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">p_start_state</span><span class="p">)</span> <span class="o">-</span> <span class="n">value</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">p_start_state</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">evd</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Value-Iteration">Value Iteration<a class="anchor-link" href="#Value-Iteration"> </a></h2>
</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-python"><pre><span></span><span class="k">def</span> <span class="nf">value</span><span class="p">(</span><span class="n">policy</span><span class="p">,</span> <span class="n">n_states</span><span class="p">,</span> <span class="n">transition_probabilities</span><span class="p">,</span> <span class="n">reward</span><span class="p">,</span> <span class="n">discount</span><span class="p">,</span>
                    <span class="n">threshold</span><span class="o">=</span><span class="mf">1e-2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the value function associated with a policy.</span>
<span class="sd">    policy: List of action ints for each state.</span>
<span class="sd">    n_states: Number of states. int.</span>
<span class="sd">    transition_probabilities: Function taking (state, action, state) to</span>
<span class="sd">        transition probabilities.</span>
<span class="sd">    reward: Vector of rewards for each state.</span>
<span class="sd">    discount: MDP discount factor. float.</span>
<span class="sd">    threshold: Convergence threshold, default 1e-2. float.</span>
<span class="sd">    -&gt; Array of values for each state</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_states</span><span class="p">)</span>

    <span class="n">diff</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">diff</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">:</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_states</span><span class="p">):</span>
            <span class="n">vs</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">policy</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
            <span class="n">v</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">transition_probabilities</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">*</span>
                       <span class="p">(</span><span class="n">reward</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">discount</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                       <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_states</span><span class="p">))</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">vs</span> <span class="o">-</span> <span class="n">v</span><span class="p">[</span><span class="n">s</span><span class="p">]))</span>

    <span class="k">return</span> <span class="n">v</span>

<span class="k">def</span> <span class="nf">optimal_value</span><span class="p">(</span><span class="n">n_states</span><span class="p">,</span> <span class="n">n_actions</span><span class="p">,</span> <span class="n">transition_probabilities</span><span class="p">,</span> <span class="n">reward</span><span class="p">,</span>
                  <span class="n">discount</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">1e-2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the optimal value function.</span>
<span class="sd">    n_states: Number of states. int.</span>
<span class="sd">    n_actions: Number of actions. int.</span>
<span class="sd">    transition_probabilities: Function taking (state, action, state) to</span>
<span class="sd">        transition probabilities.</span>
<span class="sd">    reward: Vector of rewards for each state.</span>
<span class="sd">    discount: MDP discount factor. float.</span>
<span class="sd">    threshold: Convergence threshold, default 1e-2. float.</span>
<span class="sd">    -&gt; Array of values for each state</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_states</span><span class="p">)</span>

    <span class="n">diff</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">diff</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">:</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_states</span><span class="p">):</span>
            <span class="n">max_v</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;-inf&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_actions</span><span class="p">):</span>
                <span class="n">tp</span> <span class="o">=</span> <span class="n">transition_probabilities</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">max_v</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">reward</span> <span class="o">+</span> <span class="n">discount</span><span class="o">*</span><span class="n">v</span><span class="p">))</span>

            <span class="n">new_diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">-</span> <span class="n">max_v</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">new_diff</span> <span class="o">&gt;</span> <span class="n">diff</span><span class="p">:</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="n">new_diff</span>
            <span class="n">v</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_v</span>

    <span class="k">return</span> <span class="n">v</span>

<span class="k">def</span> <span class="nf">find_policy</span><span class="p">(</span><span class="n">n_states</span><span class="p">,</span> <span class="n">n_actions</span><span class="p">,</span> <span class="n">transition_probabilities</span><span class="p">,</span> <span class="n">reward</span><span class="p">,</span> <span class="n">discount</span><span class="p">,</span>
                <span class="n">threshold</span><span class="o">=</span><span class="mf">1e-2</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stochastic</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the optimal policy.</span>
<span class="sd">    n_states: Number of states. int.</span>
<span class="sd">    n_actions: Number of actions. int.</span>
<span class="sd">    transition_probabilities: Function taking (state, action, state) to</span>
<span class="sd">        transition probabilities.</span>
<span class="sd">    reward: Vector of rewards for each state.</span>
<span class="sd">    discount: MDP discount factor. float.</span>
<span class="sd">    threshold: Convergence threshold, default 1e-2. float.</span>
<span class="sd">    v: Value function (if known). Default None.</span>
<span class="sd">    stochastic: Whether the policy should be stochastic. Default True.</span>
<span class="sd">    -&gt; Action probabilities for each state or action int for each state</span>
<span class="sd">        (depending on stochasticity).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">optimal_value</span><span class="p">(</span><span class="n">n_states</span><span class="p">,</span> <span class="n">n_actions</span><span class="p">,</span> <span class="n">transition_probabilities</span><span class="p">,</span> <span class="n">reward</span><span class="p">,</span>
                          <span class="n">discount</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">stochastic</span><span class="p">:</span>
        <span class="c1"># Get Q using equation 9.2 from Ziebart&#39;s thesis.</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_states</span><span class="p">,</span> <span class="n">n_actions</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_states</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_actions</span><span class="p">):</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">transition_probabilities</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">Q</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">reward</span> <span class="o">+</span> <span class="n">discount</span><span class="o">*</span><span class="n">v</span><span class="p">)</span>
        <span class="n">Q</span> <span class="o">-=</span> <span class="n">Q</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">n_states</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>  <span class="c1"># For numerical stability.</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">n_states</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">Q</span>

    <span class="k">def</span> <span class="nf">_policy</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_actions</span><span class="p">),</span>
                   <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span><span class="n">transition_probabilities</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">*</span>
                                     <span class="p">(</span><span class="n">reward</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">discount</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                                     <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_states</span><span class="p">)))</span>
    <span class="n">policy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">_policy</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_states</span><span class="p">)])</span>
    <span class="k">return</span> <span class="n">policy</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="MaxEnt-Objectworld">MaxEnt Objectworld<a class="anchor-link" href="#MaxEnt-Objectworld"> </a></h2>
</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-python"><pre><span></span><span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">grid_size</span><span class="p">,</span> <span class="n">discount</span><span class="p">,</span> <span class="n">n_objects</span><span class="p">,</span> <span class="n">n_colours</span><span class="p">,</span> <span class="n">n_trajectories</span><span class="p">,</span> <span class="n">epochs</span><span class="p">,</span>
         <span class="n">learning_rate</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Run maximum entropy inverse reinforcement learning on the objectworld MDP.</span>
<span class="sd">    Plots the reward function.</span>
<span class="sd">    grid_size: Grid size. int.</span>
<span class="sd">    discount: MDP discount factor. float.</span>
<span class="sd">    n_objects: Number of objects. int.</span>
<span class="sd">    n_colours: Number of colours. int.</span>
<span class="sd">    n_trajectories: Number of sampled trajectories. int.</span>
<span class="sd">    epochs: Gradient descent iterations. int.</span>
<span class="sd">    learning_rate: Gradient descent learning rate. float.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">wind</span> <span class="o">=</span> <span class="mf">0.3</span>
    <span class="n">trajectory_length</span> <span class="o">=</span> <span class="mi">8</span>

    <span class="n">ow</span> <span class="o">=</span> <span class="n">Objectworld</span><span class="p">(</span><span class="n">grid_size</span><span class="p">,</span> <span class="n">n_objects</span><span class="p">,</span> <span class="n">n_colours</span><span class="p">,</span> <span class="n">wind</span><span class="p">,</span>
                                 <span class="n">discount</span><span class="p">)</span>
    <span class="n">ground_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ow</span><span class="o">.</span><span class="n">reward</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ow</span><span class="o">.</span><span class="n">n_states</span><span class="p">)])</span>
    <span class="n">policy</span> <span class="o">=</span> <span class="n">find_policy</span><span class="p">(</span><span class="n">ow</span><span class="o">.</span><span class="n">n_states</span><span class="p">,</span> <span class="n">ow</span><span class="o">.</span><span class="n">n_actions</span><span class="p">,</span> <span class="n">ow</span><span class="o">.</span><span class="n">transition_probability</span><span class="p">,</span>
                         <span class="n">ground_r</span><span class="p">,</span> <span class="n">ow</span><span class="o">.</span><span class="n">discount</span><span class="p">,</span> <span class="n">stochastic</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">trajectories</span> <span class="o">=</span> <span class="n">ow</span><span class="o">.</span><span class="n">generate_trajectories</span><span class="p">(</span><span class="n">n_trajectories</span><span class="p">,</span>
                                            <span class="n">trajectory_length</span><span class="p">,</span>
                                            <span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">policy</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>
    <span class="n">feature_matrix</span> <span class="o">=</span> <span class="n">ow</span><span class="o">.</span><span class="n">feature_matrix</span><span class="p">(</span><span class="n">discrete</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">irl</span><span class="p">(</span><span class="n">feature_matrix</span><span class="p">,</span> <span class="n">ow</span><span class="o">.</span><span class="n">n_actions</span><span class="p">,</span> <span class="n">discount</span><span class="p">,</span>
        <span class="n">ow</span><span class="o">.</span><span class="n">transition_probability</span><span class="p">,</span> <span class="n">trajectories</span><span class="p">,</span> <span class="n">epochs</span><span class="p">,</span> <span class="n">learning_rate</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">pcolor</span><span class="p">(</span><span class="n">ground_r</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">grid_size</span><span class="p">,</span> <span class="n">grid_size</span><span class="p">)))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Groundtruth reward&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">pcolor</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">grid_size</span><span class="p">,</span> <span class="n">grid_size</span><span class="p">)))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Recovered reward&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_png output_subarea ">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAYQAAAEICAYAAABfz4NwAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAADh0RVh0U29mdHdhcmUAbWF0cGxvdGxpYiB2ZXJzaW9uMy4yLjIsIGh0dHA6Ly9tYXRwbG90bGliLm9yZy+WH4yJAAAgAElEQVR4nO3de9wcZX338c+XnAgESEIg5MRJ86gIApqCikVOkkAtQR9A6KMGgVKeiofaVkJ5qpZqX6htPVSspIiiUg5GkTwlNgQQqUUOAQMhnBIimiOBhFMChOS+f/1jrhsmy87uzO7s7M7cv3de+8rszDUz1+79m/3NNXPNjMwM55xzboduV8A551xv8ITgnHMO8ITgnHMu8ITgnHMO8ITgnHMu8ITgnHMO8IRQl6R9JZmkoR1ez/clfbGT6yhCVT6Ha19R207eJJ0p6Vfdrke3dS0hSDpd0l2SNktaH4b/XJK6Vackkm6TdE6by/CAG6QkPSHpJUmbJK0LCXRUt+vlXK2uJARJfwl8A/gqsBcwHjgPOAIYnjDPkMIqmFE39oa6tQfWy3+HHvfHZjYKOAQ4FLiwy/VJpZNx1sUYLlXrpUiFJwRJuwEXA39uZnPN7AWL/MbM/o+ZbQnlvi/pXyXNl7QZOFrSW8Le+rOSlko6Kbbc7fbia/fIQzP2PEnLwvyXDrRGJA2R9I+Snpa0Avij2HxfAv4Q+FbYw/tWbHkfl7QMWFavqTxQJ0lvAb4DvCss49nYVzJG0o2SXgitpDckfG8Dyz9b0u+BW8P4syQ9LOkZSQsk7RPG/52kfwnDw0JL7Kvh/UhJL0saG97/OOy5Pifpdklvja233t/hUEn3hTpfC+yY8s8/6JnZOmABUWIAQNI7Jd0R4vJ+SUfFpo2V9D1Ja8Lf+GexaX8qabmkjZLmSZoYxv+rpH+Mr1fSDZI+E4YnSvqJpKck/VbSJ2PlviBprqQfSXoeOFPSbpK+K2mtpNWSvjiwY9Bo26kntJYukPQAsFnS0KTPL+loSUti8y6UdE/s/X9JOjkMz5b0eIjJhyR9IFbuTEn/LelrkjYAX5C0e/jOnpd0N1B3uxt0zKzQFzAD2AYMbVLu+8BzRK2GHYBdgOXA3xC1Io4BXgDeFMrfBpwTm/9M4Fex9wb8BzAa2Bt4CpgRpp0HPAJMAcYCvwjlh9Zbdmx5C0P5kcC+8Xlq56utT+wzbgAOA4YCVwHXJHwfA8v/AbBzWOfM8J28Jcz//4A7QvljgCVh+N3A48BdsWn3x5Z9Vvh+RwBfBxY3+DvsCvwO+AtgGHAKsBX4YtGxVJYX8ARwXBieDCwBvhHeTwoxcGL4ft8X3u8Rpt8IXAuMCd/3e2N/w6eBt4e/278At4dpRwIrAYX3Y4CXgIlhHfcCnyPajvYHVgDTQ9kvhL/nyaHsSOB64LIQd3sCdwN/lmbbSfguFofyIxt9/jD9ZWBc+OxPAqtDrI4Mn2n3sNxTY5/vQ8BmYEJs29sGfIJoOxkJXANcFz7TgWG5v2r3b132Vzc2jg8D62rG3QE8G/7AR4Zx3wd+ECvzh8A6YIfYuKuBL4Th22ieEN4Te38dMDsM3wqcF5t2POkSwjGx9/vWbgikSwiXx96fCDyS8L0NLH//2LifA2fH3u8AvAjsE9uYdgdmEyXSVcAo4O+AbyasZ3RYz24Jf4cjgTWEH5vY388TQnLMPwFsItqBMeAWYHSYdgHww5ryC4BZwASgHxhTZ5nfBb4Sez+K6Id8X0DA72Pb0p8Ct4bhw4Hf1yzrQuB7YfgLhMQS3o8HtgAjY+POAH6RZttJ+C7Oir1P/Pxh+L+ADwLvBG4i2m5nAEcDDzT4zhcDM8PwmfHPDAwJ39WbY+P+AU8IXTmHsAEYFz+0YmbvNrPRYVq8TitjwxOBlWbWHxv3O6I9jLTWxYZfJNqIXl12zXLTWNm8SMt1SrPOfYBvhKb2s8BGoh+DSWb2ErAIeC/Rj/gviX64jwjjfgmvNvkvCc3t54k2WIj2yuqtcyKw2sJWFKT9vgazk81sF+Ao4M289v3uA5w68DcMf8f3ECWDKcBGM3umzvImEvvezWwT0fYzKfxtriH64Qb4E6LW58D6Jtas72+IfvgH1MbYMGBtrPxlRC2FgXpk3XZql5/0+SGK06N4LYZvI4rfV2MYQNJHJS2OLeNAkmN4D6KWQivbfKV1IyH8mmiPY2aKsvEfnTXAFEnxOu9N1NSDqIm4U2zaXhnqtJZo44svN6keSeM3h/+T6pDXbWXjy1lJ1HQfHXuNNLM7wvRfEh1aOBS4J7yfTnSI6vZQ5k+I/hbHAbsR7WFClFjqrXMtMEnarjdY7fflEpjZL4laXQPH+FcS7SHH/4Y7m9klYdpYSaPrLGoN0Y8pAJJ2JmoNDmwPVwOnhHNKhwM/ia3vtzXr28XMToxXMza8kmh7HRcrv6uZDZxnarbt1P0aapaf9Pnh9Qnhl9QkhPAZ/w04n+gQ0mjgQZJj+CmiQ0hZ6115hScEM3uW6JDFtyWdImkXSTtIOoToeF6Su4j2oD8bTpIeBfwx0Z4QRE3ED0raSdIbgbMzVOs64JOSJksaQ3SIJe5JomOtjT7XU0Qb44fDXvdZbH+i6klgsqS6vaha9B3gwoGTwOHk36mx6b8EPgo8ZGavEA5hEf0gPBXK7EK0wW8gSmb/0GSdvybamD4Z/g4fJEowLr2vA++TdDDwI+CPJU0PcbOjpKMkTTaztUSHBb8taUz4vo8My7ga+JikQySNIPq73WVmTwCY2W+IzjFcDiwI2x1Ex/9fCCd2R4Z1HijpD+pVNNThJuCfJO0attU3SHpvKNJs22km8fOH6XcAbyKKsbvNbClRIjyc13Zqdib6wX8KQNLHiFoIdZlZH/BTopPLO0k6gOgQ3aDXlW6nZvYV4DPAZ4l+KJ8kaoZeQBQA9eZ5hSgBnEAU6N8GPmpmj4QiXwNeCcu6kteayGn8G9Fxy/uB+4iCJe4bRHtbz0j6ZoPl/Cnw10Q/rm+t+Sy3AkuBdZKezlC3RGZ2PfBl4JpwuOdBou9nwB1E5xIGNpyHiM4r3B4r8wOi5vLqMP3OJut8heiY7plEh6g+xOu/L9dASMY/AD5nZiuJWmh/Q/SDtpIohga2zY8QHe9+BFgPfDos42bgb4n2/NcS7XycXrOqfydq+f17bN19wPuJejn9lteSxm4NqvxRohPQDwHPAHN57ZBOs22noWaf38w2h+UuDbEH0U7J78xsfSjzEPBPYfyTwEHAfzdZ9flEh2fXEbXYvpel3lU10AvBOefcIOe3rnDOOQekSAiSrlB0a4kHY+PGhotEloX/x3S2ms69Xr3YrJkuSd9UdPHWA5LeHps2S9GFeNskrYqN99h2g1aaFsL3ifr9xs0GbjGzqUR9qrOeSHIuD9/n9bEZdwIwNbzOBf4Voh994PNEPayOBfaM/fB7bLtBq2lCMLPbiU4exs0kOnFL+P/knOvlXFMJsRk3k+iiOjOzO4HRkiYQdb1daGY3Ep1Q38RricVj2w1ard7kaXzojgbRWfrxSQUlnUu0d4aGD3/HsPF7JhUd9A4a81TzQiVw7wNbnjazPepNm370zrZhY1/a5Swl6hU1YI6ZzclQlUlsf/HRqjCudvxWXrvAMVVsx+N6CEPesRO7pq6URmTreWzDst1PsH949lOD20ZmnGFEf/MyMcOGpvubD9h92KZM5bfYsEzlAbb2Z/teNzyyITGuIXNsLzCzRq3brmj7rn9mZpISuyqFDXgOwIi9p9ikv/p0u6usrLtPu6zbVcjFkAnLEq/63LCxj7sXpLsGaMiEZS+b2bTcKpZRo9iOx/WuGmuH69jUyx06Zb9M9dg6oVGP0NfbtHfWX3fYcGC2u87b/pubF4qZMq7exdbJPjL5rkzlH385+47mqpeznR76weFXNLyaOWNsj2teqnit9jJ6MjS9Cf+vz69KrsoM6E/5Lwer2f5q1MlhXO34Ybx2ha/HtmtJwbHdEa0mhHm8dmXfLOCGfKrjqs4wtlpfqlcO5gEfDb2N3gk8Fw4HLQCODyeSdyW6QGlBbB6PbZdZwbHdEU0PGUm6muheIuNC97zPA5cA10k6m+ik3GmdrKSrlrz2kBJicxiAmX0HmE90B9nlRLc9+ViYtlHS3xPdEXTg+MoDkjy2XVtyjO0ZRHdIGEJ0R+RLaqaPILra/R1Ed0b40MBtS9rRNCGY2RkJk9IfNHUuMIy+nK6ObxCbA9MN+HjCtCuAKxJm9dh2meUV24oePnQp0bMhVgH3SJoXbtEx4GzgGTN7o6TTiW5h86F21+1XKrvC9WOpXs6VTU6xfRiw3MxWhPs3XcPr7w4d7x49Fzi25g7ELfFni7pCGdDnP/augjLG9jhJi2Lv412q63WXPrxm/lfLmNk2Sc8R3f68rRtnekJwhfO9f1dVGWL76W52qU7iCcEVyoCtfoddV0E5xnZSd+l6ZVYpevrkbkQnl9vi5xBcoQyjL+XLuTLJMbbvAaZK2i88UOt0ou7QcfHu0acQPTO77Y3GWwiuWAZ9/lvvqiin2A7nBM4nujZmCHCFmS2VdDGwyMzmAd8FfihpOdH9vGofjtQSTwiuUNHVnM5VT56xbWbzia6jiY/7XGz4ZeDU2vna5QnBFUz00XbvOOd6UPlj2xOCK1R04q3cG41z9VQhtj0huEJFfbXLvdE4V08VYtsTgitcf8n3opxLUvbY9oTgClWFvSjn6qlCbHtCcIUyRJ9f/uIqqAqx7QnBFa7szWrnkpQ9tj0huEIZ4hXL9ixb58qgCrHtCcEVKrp4p9zNaufqqUJse0JwhSv7iTfnkpQ9tj0h9JA3XvdnmedZftplHajJa6ZPPLiFuZYlTjETfVbuvajX2XkkOuhtqYu/OGZEpsVvnphtM31p9+w/Sln/JGN2eTFT+ZMmLMlU/udPH5SpfCt+9/yYXJdXhdgud+1dKfWjVK80JM2Q9Kik5ZJm15n+NUmLw+sxSc/GpvXFptXeTdK5zPKM7W7wFoIrVHTiLZ+wS/PsWTP7i1j5TwCHxhbxkpkdkktl3KCXZ2x3i7cQXKEGTryleaWQ5tmzcWcAV7f/KZx7vZxjuyt6t2ausvpMqV4p1Hv27KR6BSXtA+wH3BobvaOkRZLulHRyq5/HuQE5xnZXlLt940on49WcjR5EntXpwFwz64uN28fMVkvaH7hV0hIze7zF5btBzq9Udq4F/el7YjR7EHmaZ88OOB34eHyEma0O/6+QdBvR+QVPCK5lGWK7J5W79q50ohuA7ZDqlUKaZ88i6c3AGODXsXFjJI0Iw+OAI4CHaud1Lq2cY7srvIXgCmWIrTld3p/y2bMQJYprah5C/hbgMkn9RDtGl8R7JzmXVZ6x3S2eEFyhzMj14p1mz54N779QZ747gM5f/eQGjbxjuxs8IbiC9faFOc61rvyx7QnBFcoo/16Uc/VUIbY9IbjC9fJJNefaUfbY9oTgCmWo9A8Rca6eKsS2JwRXKAO2lvx+L87VU4XYLnftXQmp9PeMd66+8se2JwRXKKP8V3M6V08VYtsTgitc2feinEtS9thuK51J+gtJSyU9KOlqSTvmVTFXTWai33ZI9eomj22XVVliu5GWayZpEvBJYJqZHUh064DT86qYq6boxNuQVK9u8dh2rSgqtiWNlbRQ0rLwf91ngbbyRMB2U9VQYKSkocBOwJo2l+cqL3rubJpXl3lsu4wKi+3ZwC1mNhW4Jbyv5yUzOyS8Tkqz4JbPIYT7yP8j8HvgJeAmM7uptpykc4FzAYaMyfeh1i676RMP7ur6oxNvvX2cNU1sx+N6+KgxbDhoVMfqs2lytvJbxvU1L1Rj2B4vZyr/3OaRmcrf8cwbMpV/9pVsR+ieeGr3TOUBtj47IvM8jRQY2zOBo8LwlcBtwAV5LLidQ0ZjiCq2HzAR2FnSh2vLmdkcM5tmZtOGjNq59Zq6yuj1WwSnie14XA/d0ePaRTLE9rjwtL6B17kZVjPezNaG4XXA+IRymZ8I2E4vo+OA35rZUwCSfgq8G/hRG8t0FVeSqzk9tl1mGWO74cOfJN0M7FVn0kXbrdPMJFmdctDCEwHbSQi/B94paSeiZvWxwKLGszhHTz9kPPDYdi3JK7bN7LikaZKelDTBzNZKmgCsT1hG5icCtlx7M7sLmAvcBywJy2r1ebdukDCDrf07pHp1r44e2y67AmN7HjArDM8Cbqgt0OoTAdu6MM3MPg98vp1luMElalb3fAvBY9tlVmBsXwJcJ+ls4HfAaQCSpgHnmdk5tPhEQL9S2RWu7FdzOpekiNg2sw1EhzFrxy8CzgnDLT0R0BOCK1QZup0614oqxHbvt91dxeR7eb+kGZIelbRc0usu0JF0pqSnYldsnhObNitc7blM0qzaeZ3Lpvy3rvAWgitcXs+dlTQEuBR4H7AKuEfSvDrHSq81s/Nr5h1LdI5gGtHO3b1h3mdyqZwblPyZys5lEPXEyO0+RYcBy81sBYCka4guKGt68gyYDiw0s41h3oXADODqvCrnBpecY7srerft4ipp4OKdNC+aX805CVgZe78qjKv1vyU9IGmupCkZ53UulYyx3ZO8heAKl6FZ3fBqzpT+P3C1mW2R9GdE9345ps1lOldX2Q8ZeQvBFWqgJ0ZOe1GrgSmx95PDuNfWZ7bBzLaEt5cD70g7r3NZ5BzbXeEJwRUux54Y9wBTJe0naTjRMwu2u+97uLR/wEnAw2F4AXB8uKJzDHB8GOdcy7yXkXMZmIltOW0QZrZN0vlEP+RDgCvMbKmki4FFZjYP+KSkk4BtwEbgzDDvRkl/T5RUAC4eOMHsXCvyjO1u8YTgCpdnk9nM5gPza8Z9LjZ8IXBhwrxXAFfkVhk36PXy4aA0PCG4QlXhak7n6qlCbHtCcIUr+0bjXJKyx7YnBFeokjwgx7nMqhDbnhBc4creV9u5JGWPbU8IrlBmsK2LD79xrlOqENueEHrI8tMuyzzP9IkHd6AmnVX2ZnWtbTvCs29OeqxtHRmKAvSPyDbDiL1ezLYC4G17rW1eKGbN5l0zlX9g3YTmhWJGjdzSvFBM8mOFk+2wOf/7DpU9tj0huEJV4Tirc/VUIbY9IbjCWck3GueSlD22PSG4wpX9xJtzScoe254QXKHMyn+c1bl6qhDbnhBcwURfyXtiOFdf+WPbE4IrXNmPszqXpOyx7QnBFaoK93txrp4qxLYnBFcsi461Olc5FYhtTwiucGXvieFckrLHticEVyirwIk35+qpQmx7QnCFK3uz2rkkZY9tTwiucGXvieFckrLHdrnbN650zKKNJs0rDUkzJD0qabmk2XWmf0bSQ5IekHSLpH1i0/okLQ6veTl+TDcI5R3b3eAJwRWu35Tq1YykIcClwAnAAcAZkg6oKfYbYJqZvQ2YC3wlNu0lMzskvE7K59O5wSyv2G5E0qmSlkrqlzStQbmGO0v1eEJwhTNL90rhMGC5ma0ws1eAa4CZ26/LfmFmA/eDvhOYnOdncS4ux9hu5EHgg8DtSQVS7iy9jp9DcIUyRH/6nhjjJC2KvZ9jZnNi7ycBK2PvVwGHN1je2cDPY+93DMvfBlxiZj9LWzHnamWM7dbXY/YwgNSwpfHqzlIoO7Cz9FCjmTwhuMJl2EF62swSm8RZSPowMA14b2z0Pma2WtL+wK2SlpjZ43mszw1OGWK72c5Ou7LuLAFtJgRJo4HLgQOJvouzzOzX7SzTVZzl2hNjNTAl9n5yGLcdSccBFwHvNbNXH8VlZqvD/ysk3QYcCjwe5vHYdtlki+2GOzuSbgb2qjPpIjO7oZXqpdFuC+EbwH+a2SmShgM75VAnV3X59dW+B5gqaT+iRHA68CfxApIOBS4DZpjZ+tj4McCLZrZF0jjgCLY/4eyx7bLLKbbN7Lg2F5FqZ6lWywlB0m7AkcCZAOGk3iutLs8NHnm1EMxsm6TzgQXAEOAKM1sq6WJgkZnNA74KjAJ+HI65/j70KHoLcJmkfqLOFZeY2UPgse1a10NdSpvuLNXTTgthP+Ap4HuSDgbuBT5lZpvjhSSdC5wLMGTMmDZW56rAgP7+/DYaM5sPzK8Z97nYcN09LTO7AzgoYbFNYzse10M9rh35x3YSSR8A/gXYA7hR0mIzmy5pInC5mZ2YtLPUbNntJIShwNuBT5jZXZK+AcwG/jZeKJwomQMwYu8pHb2w+w2fvjNT+ce//s4O1SSy/LTLMpWfPvHgDtWkhxjQO3tRSZrGdjyud5o60Ub9r2dSL/yVrdk2uxc3jsxUfgdl38xWbdotU/lNL4/IVL6/L1vvmw3rd81Unh2yf+bhm3KOw4Ji28yuB66vM34NcGLs/et2lpppp4/UKmCVmd0V3s8l2oica6igvtrt8Nh2LSlBbDfUckIws3XASklvCqOOpUkfV+eAsCeV4tUlHtuuZT0e282028voE8BVoRfGCuBj7VfJVVtv38slxmPbZVSa2E7UVkIws8VEF/s4l14P7yEN8Nh2LSlBbDfiVyq7YhlYAT0xnCtcBWLbE4LrgnJvNM4lK3dse0JwxSt5s9q5RCWPbU8Irngl32icS1Ty2PaE4IpVjgvTnMuuArHtCcEVrpcvzHGuHWWPbU8Irngl74nhXKKSx7YnBFe4Fm6141wplD22PSG4YvX4pfvOtawCse0JwRVMpT/x5lx95Y9tTwiueCXfi3IuUclj2xOCK15/tyvgXIeUPLY9IbhiVaCvtnN1VSC223lAjnMtkaV7pVqWNEPSo5KWS5pdZ/oISdeG6XdJ2jc27cIw/lFJ0/P6fG7wyjO2u8ETgiteTg8RkTQEuBQ4ATgAOEPSATXFzgaeMbM3Al8DvhzmPYDoweNvBWYA3w7Lc651JX9AjicEV2aHAcvNbIWZvQJcA8ysKTMTuDIMzwWOlaQw/hoz22JmvwWWh+U5N2h5QnCFy9CsHidpUex1bs2iJgErY+9XhXF1y5jZNuA5YPeU8zqXSdkPGfX0SeXlp12WbYbTsq7h/qwzdNSCNdnrM33iwR2oSQcZWS7vf9rMev6pZbsNf4n37700dflHNu2VafkPa89M5d+y5/pM5QGOHPtYpvJ3Prt/pvL3rZmcqfyuYzdnKr/5xRGZygNsG5XzL3O22O5J3kJwxcvvOOtqYErs/eQwrm4ZSUOB3YANKed1Lhs/h+BcNjk2q+8BpkraT9JwopPE82rKzANmheFTgFvNzML400MvpP2AqcDdeXw+N3j5ISPnssppgzCzbZLOBxYAQ4ArzGyppIuBRWY2D/gu8ENJy4GNREmDUO464CFgG/BxM+vLp2Zu0OrhH/s0PCG44uW40ZjZfGB+zbjPxYZfBk5NmPdLwJfyq40b9DwhOJderzeZnWtVFWLbE4IrXsl7YjiXqOSx7SeVXeHKfuLNuSRFxLakUyUtldQvKbFbtqQnJC2RtFjSojTL9haCK57/2LuqKia2HwQ+CKS5UOtoM3s67YI9Ibhi+d6/q6qCYtvMHgaI7sCSLz9k5IpX8ot3nEvUW7FtwE2S7q1z25e6vIXgCqeSP0TEuSQZYntczXH9OWY259XlSDcD9e5xcpGZ3ZByHe8xs9WS9gQWSnrEzG5vNIMnBOecK17D+3SZ2XHtrsDMVof/10u6nuhuvg0Tgh8ycsXrrWa1c/npkdiWtLOkXQaGgeOJTkY35AnBFStltzw/8exKp6DYlvQBSauAdwE3SloQxk+UNHDV/njgV5LuJ7pH141m9p/Nlu2HjFzx/MfeVVUxvYyuB66vM34NcGIYXgFkvje+JwRXPE8IrqpKHtueEFyhhPcyctVUhdhu+xyCpCGSfiPpP/KokKu4Ep1D8Nh2mZQotpPkcVL5U8DDOSzHDRY90hMjBY9tl015YruuthKCpMnAHwGX51MdNyiUYKPx2HYtKUFsN9LuOYSvA58FdkkqEC6ZPhdg70lDWX5amvsxubQWrLk/U/npEzN3PMhdLzeZYxrGdjyuR44fxSOb6l1UWt8OGX8RJuz2fKbyWZcPsPzF8ZnK7zhka6byx+/7aKbyv9k4KVP5l14enqk8QH8HjveXJLYTtdxCkPR+YL2Z3duonJnNMbNpZjZtj92HtLo6VyU9vheVJrbjcT1i9MgCa+d6Wo/HdjPtHDI6AjhJ0hPANcAxkn6US61cdVnUEyPNqx2SxkpaKGlZ+H9MnTKHSPp1uLf8A5I+FCYdAcyStBVYCJwo6cb2auQqr6DY7qSWE4KZXWhmk81sX6IHl99qZh/OrWauuorZi5oN3GJmU4FbwvtaLwIfNbO3AjOAr0sabWYXAj8GzgDeB8w3sz9qu0au+gZxC8G5lhTUNW8mcGUYvhI4ubaAmT1mZsvC8BpgPbBH22t2g1bZu53mcmGamd0G3JbHstwgkH6DaHiL4CbGm9naMLyO6N4uiSQdBgwHHo+N/hKwBbhF0ggz25Jy3W6w6uEf+zT8SmVXrGxN5oa3CG50z/jtVmlmUvJ+maQJwA+BWWY2cIT3QqJEMhyYA1wAXJy65m7w6fHDQWl4QnCFEvk1mRvdM17Sk5ImmNna8IO/PqHcrsCNRA8euTO27IHWxRZJ3wP+Kp9au6rKM7a7xc8huMIVdJx1HjArDM8CXveUKUnDie4a+QMzm1szbUL4X0TnH5reS965sp9D8ITgildMT4xLgPdJWgYcF94jaZqkgauPTwOOBM6UtDi8DgnTrpK0BFgCjAO+2HaNXPWVvJeRHzJyxStggzCzDcCxdcYvAs4Jwz8C6l47Y2bHdLSCrpp6+Mc+DU8Irlg93mR2rmUViG1PCK54Jd9onEtU8tj2hOAK18uX7jvXjrLHticEV7iyN6udS1L22PaE4IrV470snGtZBWLbE4IrXsk3GucSlTy2PSG4QlXhak7n6qlCbHtCcIVTf8m3GucSlD22PSG4YlXgOKtzdVUgtj0huMKVvVntXJKyx7YnBFe8km80ziUqeWx7QhhkFqy5P1P56RMPzr0OZd+LqvXytqE8vH7P1OWP3XtZpuWfP/GWTOXnbvyDTOUBHny23mMlkp055deZyu8/rO7dxxs4PFPpB3foy7h8+O3GHTPP00zZY9sTgiteyTca5xKVPLb99teuWEzbF+YAAA5ASURBVBZd3p/m5VypFBTbkr4q6RFJD0i6XtLohHIzJD0qabmk2WmW7QnBFWqgr3aZHyLiXD0FxvZC4EAzexvwGNHjXrevizQEuBQ4ATgAOEPSAc0W7AnBFc8s3cu5sikgts3sJjPbFt7eCUyuU+wwYLmZrTCzV4BrgJnNlu3nEFzhfO/fVVWG2B4naVHs/Rwzm9PCKs8Crq0zfhKwMvZ+FSnO1HtCcMWqwMU7ztWVLbafNrNpSRMl3QzU6/p1kZndEMpcBGwDrspW0WSeEFzhijhhLGks0Z7TvsATwGlm9kydcn1Ez00G+L2ZnRTG70fUzN4duBf4SGh6O5cor9g2s+Markc6E3g/cKxZ3WNQq4EpsfeTw7iG/ByCK1xBvYxmA7eY2VTglvC+npfM7JDwOik2/svA18zsjcAzwNlt18hVXkG9jGYAnwVOMrMXE4rdA0yVtJ+k4cDpwLxmy/aE4IplFHVSeSZwZRi+Ejg57YySBBwDzG1lfjdIFRfb3wJ2ARZKWizpOwCSJkqaDxBOOp8PLAAeBq4zs6XNFuyHjFzhCjrxNt7M1obhdcD4hHI7hnVsAy4xs58RHSZ6NtaTYxXRSTrnGiqiw0RotdYbvwY4MfZ+PjA/y7I9IbjiFXDibbvVmZmUuKnuY2arJe0P3CppCfBc6ho6F1fyDhOeEFyh8nyISKMTb5KelDTBzNZKmgDUvZmOma0O/6+QdBtwKPATYLSkoaGVkOqEnBvcqvCAHD+H4IplhvrTvdo0D5gVhmcBN9QWkDRG0ogwPA44Ango9Nr4BXBKo/md205xsd0xnhBc8Szlqz2XAO+TtAw4LrxH0jRJl4cybwEWSbqfKAFcYmYPhWkXAJ+RtJzonMJ3266Rq75iYrtj/JCRK1xBJ942AMfWGb8IOCcM3wEclDD/CqLL/51LreyHjDwhuGIZ0MNNZudaVoHY9oTgilfubca5ZCWP7ZbPIUiaIukXkh6StFTSp/KsmKuuXr/9tce2a1Wvx3Yz7bQQtgF/aWb3SdoFuFfSwthJOefq6uVeFoHHtmtJCWK7oZZbCGa21szuC8MvEF0e7VdzusbS9sLo4nblse1aUoLYbiaXcwiS9iW6oOeuOtPOBc4F2HuSn7IY7KKLd3p4i6iRFNvxuB66x26F18v1nrLFdj1t/0JLGkV0Zeenzez52unh3jNzAKYdvGO5v60KmD7x4G5XAUryvORGsR2P69Fv3tPesPuG1Mvdf+RTmerxhztmKs59GZcPsOjpKc0Lxdz27JuyraDuU3+Tbeobnqn88CF92VYAaKsyz9NUSWI7SVsJQdIwog3mKjP7aT5VclVXhr0oj23XijLEdiMtJ4Rwi+DvAg+b2T/nVyVXaT1+DBU8tl2LShDbzbRz64ojgI8Ax4R7ci+WdGKzmdxgV4r7vXhsuxaUIrYbarmFYGa/IjqP4lw2Pd6s9th2Levx2G7Gu/24Ylkxz1R2rnAViG1PCK54Jd+Lci5RyWPbE4IrXrm3GeeSlTy2PSG4wqm/5O1q5xKUPbY9IbhiGaW/eMe5uioQ254QXKGElf7iHefqqUJse0JwxSv5RuNcopLHtj9T2RXPLN2rDZLGSlooaVn4f0ydMkfHLjxbLOllSSeHad+X9NvYtEPaqpAbHAqI7U7yhOCKNXCcNc2rPbOBW8xsKnBLeL99Vcx+YWaHmNkhwDHAi8BNsSJ/PTDdzBa3XSNXbcXFdsf4ISNXuIJ6YswEjgrDVwK3ARc0KH8K8HMze7Gz1XJVVvZeRt5CcAVL2aRuv1k93szWhuF1wPgm5U8Hrq4Z9yVJD0j6mqQR7VbIVV1hsd0x3kJwxTKybBDjJC2KvZ8TnkMAgKSbgb3qzHfRdqs0Myn5SbaSJgAHAQtioy8kSiTDiZ57cAFwcdqKu0EoW2z3JE8IrnjpW9VPm9m0pIlmdlzSNElPSppgZmvDD/76Bus5DbjezLbGlj3Qutgi6XvAX6WutRu8yn3EyA8ZueLJLNWrTfOAWWF4FnBDg7JnUHO4KCSRgWcjnAw82G6FXPUVEduSvirpkXA483pJdZ9HJ+kJSUtCL7lF9crU8oTgilfMcdZLgPdJWgYcF94jaZqkywcKhWcmTwF+WTP/VZKWAEuAccAX262QGwSKie2FwIFm9jbgMaLDm0mODr3kElvacX7IyBXLDPo63642sw3AsXXGLwLOib1/AphUp9wxnayfq6DiYjveNfpOoh5yufAWgiteyXtiOJcofWyPk7Qo9jq3xTWeBfw8qTbATZLuTbv8QlsIjz2wE9MnHpy6/II193ewNtllqXsrWvm8na5TR1Tsx37YDn1M2unZ1OVftmyb3Tee2TdT+bufy1Ye4OnnRmUqf++W4ZnKP/HC2Ezl17+wS6bymzfulKk8wJAtHXgoXvrYbthholEPOjO7IZS5CNgGXJWwmPeY2WpJewILJT1iZrc3qpQfMnLFMqCHnynrXMtyjO1GPegAJJ0JvB841qx+FjKz1eH/9ZKuBw4DGiYEP2TkCmZg/elezpVKMbEtaQbwWeCkpCvrJe0saZeBYeB4UvSU8xaCK5ZRyIk35wpXXGx/CxhBdBgI4E4zO0/SROByMzuR6Mr868P0ocC/m9l/NluwJwRXvIqdQ3DuVQXEtpm9MWH8GuDEMLwCyHyC0ROCK54nBFdVJY9tTwiuYN6l1FVV+WPbE4IrlgElv0Wwc3VVILY9IbjilXwvyrlEJY9tTwiuYMVc3u9c8cof254QXLEMzK8xcFVUgdj2hOCK51cqu6oqeWx7QnDFK/lxVucSlTy2PSG4YpmVvieGc3VVILY9IbjilXwvyrlEJY9tTwiuYIb19XW7Es51QPlj2xOCK5bf/tpVVQVi2xOCK17Ju+Y5l6jksd3W8xAkzZD0qKTlkmbnVSlXXQZYv6V6tUPSqZKWSuqX1OjJVHVjWNIsSS9JekXS/ZKyPSLMDTpFxXYntZwQJA0BLgVOAA4AzpB0QF4VcxVlhT0g50HggzR4QlRSDMfGXwCMAiYBF7VbIVdxxcV2x7TTQjgMWG5mK8zsFeAaYGY+1XJVZn19qV5trcPsYTN7tEmxpBg+DBgOfDuM/zFwRlsVcoNCEbHdSe2cQ5gErIy9XwUcXltI0rnAueHtlpttbtPHuA0YMqGN2m1vHPB0+4tZ1tF1t/Z5E+uU02duyZuSJrzAMwtutrnjUi5nR0mLYu/nmNmc9qq2naQYfjPwkpltC+MfAU6Lz1gb15dN+1HquM5Zt/7O3Yyvbq07Ma4hc2x367trqOMnlcMGPAdA0iIzSzye2yndWm83193tz5w0zcxm5Liem4G96ky6yMxuyGs99fRCXHdz3YP1Mzeanmdsd0s7CWE1MCX2fnIY51whzOy4NheRFMOPACMlDQ2thDcDG9pcl3M9r51zCPcAUyXtF3pgnA7My6dazhUiKYbvAV4B/m8Yfypwbfeq6VwxWk4IYc/pfGAB8DBwnZktbTJbnsd/s+jWeru57sH4mV8l6QOSVgHvAm6UtCCMnyhpPiTHcBj/SeArwGZgLfDFBqsbjN+1f+YKkpX83hvOOefy0daFac4556rDE4JzzjmgQwmh2S0tJI2QdG2YfpekfXNY5xRJv5D0ULhlwafqlDlK0nOSFofX59pdb2zZT0haEpb7uu5pinwzfOYHJL09h3W+KfZZFkt6XtKna8rk9pklXSFpvaQHY+PGSlooaVn4f0zCvLNCmWWSZrVah27qRlyH5XYttrsR12G5hcX2YI/r7ZhZri9gCPA4sD/R1Z73AwfUlPlz4Dth+HTg2hzWOwF4exjeBXisznqPAv4j788clv0EMK7B9BOBnwMC3gnc1YHvfR2wT6c+M3Ak8Hbgwdi4rwCzw/Bs4Mt15hsLrAj/jwnDYzrxd+jUq1txHZbVtdjudlzHvvuOxfZgjuvaVydaCGluaTETuDIMzwWOlaR2Vmpma83svjD8AlGvkUntLDNnM4EfWOROYLSk/K7FhmOBx83sdzkucztmdjuwsWZ0/G95JXBynVmnAwvNbKOZPQMsBMp2EU9X4hp6PrY7HdfQ4dge5HG9nU4khHq3A6gN3lfLWNTF7zlg97wqEJrqhwJ31Zn8LkV3r/y5pLfmtU6imx3eJOleRbc1qJXme2nH6cDVCdM69ZkBxpvZ2jC8Dhhfp0ynP3sRuh7X0JXY7nZcQ3die7DE9XYq9zwESaOAnwCfNrPnaybfR9Ts3CTpROBnwNScVv0eM1staU9goaRHwp5Hxym6eOok4MI6kzv5mbdjZibJ+zF3SJdiu2txDb0R24MprjvRQkhzS4tXy0gaCuxGDrcGkDSMaIO5ysx+WjvdzJ43s01heD4wTFLam1E1ZGarw//rgeuJDjHEdfJWHycA95nZk3Xq1bHPHDw5cIgg/L++Tpkq3Oaka3EdlteV2O5yXEP3YnuwxPV2OpEQ0tzSYh4wcEb+FOBWC2dpWhWO1X4XeNjM/jmhzF4Dx3QlHUb0+fNIRDtL2mVgGDie6H78cfOAj4ZeGe8Enos1Sdt1BglN6k595pj433IWUO+mcguA4yWNCb01jg/jyqQrcQ3di+0eiGvoXmwPlrjeXifOVBP1PHiMqFfGRWHcxcBJYXhHonvMLwfuBvbPYZ3vITre+QCwOLxOBM4DzgtlzgeWEvUQuRN4d06fd/+wzPvD8gc+c3zdInroyuPAEmBaTuvemWgj2C02riOfmWjDXAtsJTpeejbRMfJbiO7DfTMwNpSdBlwem/es8PdeDnysE3HX6Vc34rqbsd3NuC4ytgd7XMdffusK55xzgF+p7JxzLvCE4JxzDvCE4JxzLvCE4JxzDvCE4JxzLvCE4JxzDvCE4JxzLvgfyTWmLN8pdTsAAAAASUVORK5CYII=
" />
</div>

</div>

</div>
</div>

</div>
    

</div>



  </div><a class="u-url" href="/2022/01/21/objectworld.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
      </div>
      <div class="footer-col">
        <p>Jupyter notebook database.</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"><li><a rel="me" href="https://github.com/recohut" target="_blank" title="recohut"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg></a></li></ul>
</div>

  </div>

</footer>
</body>

</html>
